#!/usr/bin/env node
/**
 * Comprehensive Automation Workflow Test
 * 
 * This script validates the entire automation system by testing:
 * 1. Database connectivity and schema validation
 * 2. Lead creation and workflow initialization
 * 3. Email automation services
 * 4. SMS automation services
 * 5. Meeting booking and monitoring
 * 6. Workflow orchestrator processing
 * 7. System configuration and monitoring functions
 * 8. End-to-end automation flow
 */

import { supabase } from './src/config/index.js';
import { createLead } from './src/services/supabase-service.js';
import { WorkflowOrchestrator } from './workflow-orchestrator.js';
import calendlyEmailService from './src/services/calendly-email-service.js';
import twilioSmsService from './src/services/twilio-sms-service.js';
import meetingService from './src/services/meeting-service.js';
import logger from './src/utils/logger.js';
import { generateTrackingId } from './src/utils/crypto.js';
import dotenv from 'dotenv';

// Load environment variables
dotenv.config();

class AutomationWorkflowTester {
  constructor() {
    this.trackingId = generateTrackingId();
    this.testResults = {
      database: { passed: false, errors: [] },
      leadCreation: { passed: false, errors: [] },
      emailService: { passed: false, errors: [] },
      smsService: { passed: false, errors: [] },
      meetingService: { passed: false, errors: [] },
      workflowOrchestrator: { passed: false, errors: [] },
      systemConfig: { passed: false, errors: [] },
      endToEnd: { passed: false, errors: [] }
    };
    this.testLeadIds = [];
    this.orchestrator = new WorkflowOrchestrator();
  }

  /**
   * Run all automation tests
   */
  async runAllTests() {
    console.log('üöÄ Starting Comprehensive Automation Workflow Test');
    console.log(`üìã Tracking ID: ${this.trackingId}`);
    console.log('=' .repeat(60));

    try {
      // Test 1: Database connectivity and schema validation
      await this.testDatabaseConnectivity();
      
      // Test 2: Lead creation and workflow initialization
      await this.testLeadCreationAndWorkflow();
      
      // Test 3: Email automation service
      await this.testEmailAutomation();
      
      // Test 4: SMS automation service
      await this.testSmsAutomation();
      
      // Test 5: Meeting booking and monitoring
      await this.testMeetingService();
      
      // Test 6: Workflow orchestrator processing
      await this.testWorkflowOrchestrator();
      
      // Test 7: System configuration and monitoring
      await this.testSystemConfiguration();
      
      // Test 8: End-to-end automation flow
      await this.testEndToEndFlow();
      
      // Generate final report
      this.generateTestReport();
      
    } catch (error) {
      console.error('üí• Critical test failure:', error.message);
      logger.logError(error, {
        context: 'automation_workflow_test',
        trackingId: this.trackingId
      });
    } finally {
      // Cleanup test data
      await this.cleanupTestData();
    }
  }

  /**
   * Test 1: Database connectivity and schema validation
   */
  async testDatabaseConnectivity() {
    console.log('\nüîç Test 1: Database Connectivity and Schema Validation');
    console.log('-'.repeat(50));
    
    try {
      // Test basic connectivity
      console.log('üì° Testing database connection...');
      const { data: connectionTest, error: connectionError } = await supabase
        .from('leads')
        .select('count')
        .limit(1);
      
      if (connectionError) {
        throw new Error(`Database connection failed: ${connectionError.message}`);
      }
      console.log('‚úÖ Database connection successful');
      
      // Test required tables exist
      console.log('üìã Validating required tables...');
      const requiredTables = [
        'leads',
        'workflow_automation',
        'system_config',
        'agents',
        'meetings'
      ];
      
      for (const table of requiredTables) {
        const { data, error } = await supabase
          .from(table)
          .select('*')
          .limit(1);
        
        if (error) {
          throw new Error(`Table '${table}' not accessible: ${error.message}`);
        }
        console.log(`   ‚úÖ Table '${table}' exists and accessible`);
      }
      
      // Test monitoring functions
      console.log('üîß Testing monitoring functions...');
      const { data: monitoringData, error: monitoringError } = await supabase
        .rpc('get_new_lead_monitoring_stats');
      
      if (monitoringError) {
        console.log(`   ‚ö†Ô∏è  Monitoring function warning: ${monitoringError.message}`);
      } else {
        console.log('   ‚úÖ Monitoring functions working');
      }
      
      this.testResults.database.passed = true;
      console.log('‚úÖ Database connectivity test PASSED');
      
    } catch (error) {
      this.testResults.database.errors.push(error.message);
      console.log(`‚ùå Database connectivity test FAILED: ${error.message}`);
    }
  }

  /**
   * Test 2: Lead creation and workflow initialization
   */
  async testLeadCreationAndWorkflow() {
    console.log('\nüë§ Test 2: Lead Creation and Workflow Initialization');
    console.log('-'.repeat(50));
    
    try {
      // Create test lead
      console.log('üìù Creating test lead...');
      const testLeadData = {
        id: `test_facebook_lead_${Date.now()}`,
        email: `test-automation-${Date.now()}@example.com`,
        first_name: 'Test',
        last_name: 'Automation',
        phone: '+1234567890',
        ad_id: 'test_ad_automation',
        ad_name: 'Test Automation Ad',
        adset_id: 'test_adset_automation',
        campaign_id: 'test_campaign_automation',
        campaign_name: 'Test Automation Campaign',
        form_id: 'test_form_automation',
        form_name: 'Test Automation Form',
        fields: {
          utm_source: 'automation_test',
          test_mode: true
        },
        raw_data: {
          test_automation: true,
          tracking_id: this.trackingId
        }
      };
      
      const leadResult = await createLead(testLeadData, this.trackingId);
      
      if (!leadResult || !leadResult.id) {
        throw new Error(`Lead creation failed: ${leadResult}`);
      }
      
      const leadId = leadResult.id;
      this.testLeadIds.push(leadId);
      console.log(`‚úÖ Test lead created with ID: ${leadId}`);
      
      // Verify lead in database
      console.log('üîç Verifying lead in database...');
      const { data: createdLead, error: fetchError } = await supabase
        .from('leads')
        .select('*')
        .eq('id', leadId)
        .single();
      
      if (fetchError || !createdLead) {
        throw new Error('Lead not found in database after creation');
      }
      console.log('‚úÖ Lead verified in database');
      
      // Test workflow initialization
      console.log('üîÑ Testing workflow initialization...');
      const workflowSuccess = await this.orchestrator.initializeWorkflow(leadId);
      
      if (!workflowSuccess) {
        throw new Error('Workflow initialization failed');
      }
      console.log('‚úÖ Workflow initialized successfully');
      
      // Verify workflow jobs created
      console.log('üìä Verifying workflow jobs...');
      const { data: workflowJobs, error: jobsError } = await supabase
        .from('workflow_automation')
        .select('*')
        .eq('lead_id', leadId);
      
      if (jobsError || !workflowJobs || workflowJobs.length === 0) {
        throw new Error('No workflow jobs created');
      }
      
      console.log(`‚úÖ ${workflowJobs.length} workflow jobs created`);
      workflowJobs.forEach(job => {
        console.log(`   - ${job.workflow_type}: ${job.step_name} (${job.status})`);
      });
      
      this.testResults.leadCreation.passed = true;
      console.log('‚úÖ Lead creation and workflow test PASSED');
      
    } catch (error) {
      this.testResults.leadCreation.errors.push(error.message);
      console.log(`‚ùå Lead creation and workflow test FAILED: ${error.message}`);
    }
  }

  /**
   * Test 3: Email automation service
   */
  async testEmailAutomation() {
    console.log('\nüìß Test 3: Email Automation Service');
    console.log('-'.repeat(50));
    
    try {
      console.log('üîß Testing email service initialization...');
      
      if (!calendlyEmailService) {
        throw new Error('Email service failed to initialize');
      }
      console.log('‚úÖ Email service initialized');
      
      // Test email configuration
      console.log('‚öôÔ∏è  Testing email configuration...');
      const hasEmailConfig = process.env.SMTP_HOST || process.env.SENDGRID_API_KEY;
      
      if (!hasEmailConfig) {
        console.log('‚ö†Ô∏è  Email configuration not found (SMTP_HOST or SENDGRID_API_KEY)');
        console.log('   Email service will use mock mode for testing');
      } else {
        console.log('‚úÖ Email configuration found');
      }
      
      this.testResults.emailService.passed = true;
      console.log('‚úÖ Email automation service test PASSED');
      
    } catch (error) {
      this.testResults.emailService.errors.push(error.message);
      console.log(`‚ùå Email automation service test FAILED: ${error.message}`);
    }
  }

  /**
   * Test 4: SMS automation service
   */
  async testSmsAutomation() {
    console.log('\nüì± Test 4: SMS Automation Service');
    console.log('-'.repeat(50));
    
    try {
      console.log('üîß Testing SMS service initialization...');
      
      if (!twilioSmsService) {
        throw new Error('SMS service failed to initialize');
      }
      console.log('‚úÖ SMS service initialized');
      
      // Test SMS configuration
      console.log('‚öôÔ∏è  Testing SMS configuration...');
      const hasSmsConfig = process.env.TWILIO_ACCOUNT_SID && process.env.TWILIO_AUTH_TOKEN;
      
      if (!hasSmsConfig) {
        console.log('‚ö†Ô∏è  SMS configuration not found (TWILIO_ACCOUNT_SID or TWILIO_AUTH_TOKEN)');
        console.log('   SMS service will use mock mode for testing');
      } else {
        console.log('‚úÖ SMS configuration found');
      }
      
      this.testResults.smsService.passed = true;
      console.log('‚úÖ SMS automation service test PASSED');
      
    } catch (error) {
      this.testResults.smsService.errors.push(error.message);
      console.log(`‚ùå SMS automation service test FAILED: ${error.message}`);
    }
  }

  /**
   * Test 5: Meeting booking and monitoring
   */
  async testMeetingService() {
    console.log('\nüìÖ Test 5: Meeting Service');
    console.log('-'.repeat(50));
    
    try {
      console.log('üîß Testing meeting service...');
      
      if (!meetingService) {
        throw new Error('Meeting service not available');
      }
      console.log('‚úÖ Meeting service available');
      
      // Test meeting table access
      console.log('üìã Testing meeting table access...');
      const { data: meetings, error: meetingError } = await supabase
        .from('meetings')
        .select('*')
        .limit(1);
      
      if (meetingError) {
        throw new Error(`Meeting table access failed: ${meetingError.message}`);
      }
      console.log('‚úÖ Meeting table accessible');
      
      this.testResults.meetingService.passed = true;
      console.log('‚úÖ Meeting service test PASSED');
      
    } catch (error) {
      this.testResults.meetingService.errors.push(error.message);
      console.log(`‚ùå Meeting service test FAILED: ${error.message}`);
    }
  }

  /**
   * Test 6: Workflow orchestrator processing
   */
  async testWorkflowOrchestrator() {
    console.log('\nüîÑ Test 6: Workflow Orchestrator Processing');
    console.log('-'.repeat(50));
    
    try {
      if (this.testLeadIds.length === 0) {
        throw new Error('No test leads available for orchestrator testing');
      }
      
      const testLeadId = this.testLeadIds[0];
      
      // Test workflow status retrieval
      console.log('üìä Testing workflow status retrieval...');
      const workflowStatus = await this.orchestrator.getWorkflowStatus(testLeadId);
      
      if (!workflowStatus) {
        throw new Error('Failed to retrieve workflow status');
      }
      
      console.log('‚úÖ Workflow status retrieved:');
      console.log(`   Total Jobs: ${workflowStatus.totalJobs}`);
      console.log(`   Pending: ${workflowStatus.pending}`);
      console.log(`   Completed: ${workflowStatus.completed}`);
      
      // Test job processing
      console.log('‚ö° Testing job processing...');
      
      // Update one job to be ready for immediate processing
      await supabase
        .from('workflow_automation')
        .update({ scheduled_at: new Date().toISOString() })
        .eq('lead_id', testLeadId)
        .eq('status', 'pending')
        .limit(1);
      
      const processedCount = await this.orchestrator.processPendingJobs(5);
      console.log(`‚úÖ Processed ${processedCount} workflow jobs`);
      
      this.testResults.workflowOrchestrator.passed = true;
      console.log('‚úÖ Workflow orchestrator test PASSED');
      
    } catch (error) {
      this.testResults.workflowOrchestrator.errors.push(error.message);
      console.log(`‚ùå Workflow orchestrator test FAILED: ${error.message}`);
    }
  }

  /**
   * Test 7: System configuration and monitoring
   */
  async testSystemConfiguration() {
    console.log('\n‚öôÔ∏è  Test 7: System Configuration and Monitoring');
    console.log('-'.repeat(50));
    
    try {
      // Test system config table
      console.log('üìã Testing system configuration...');
      const { data: configs, error: configError } = await supabase
        .from('system_config')
        .select('*')
        .limit(5);
      
      if (configError) {
        throw new Error(`System config access failed: ${configError.message}`);
      }
      
      console.log(`‚úÖ Found ${configs.length} system configurations`);
      configs.forEach(config => {
        console.log(`   - ${config.key}: ${JSON.stringify(config.value)}`);
      });
      
      // Test monitoring functions
      console.log('üìä Testing monitoring functions...');
      try {
        const { data: monitoringStats, error: monitoringError } = await supabase
          .rpc('get_new_lead_monitoring_stats');
        
        if (monitoringError) {
          console.log(`   ‚ö†Ô∏è  Monitoring function warning: ${monitoringError.message}`);
        } else {
          console.log('‚úÖ Monitoring functions working');
          if (monitoringStats && monitoringStats.length > 0) {
            console.log(`   Found ${monitoringStats.length} monitoring records`);
          }
        }
      } catch (funcError) {
        console.log(`   ‚ö†Ô∏è  Monitoring function not available: ${funcError.message}`);
      }
      
      this.testResults.systemConfig.passed = true;
      console.log('‚úÖ System configuration test PASSED');
      
    } catch (error) {
      this.testResults.systemConfig.errors.push(error.message);
      console.log(`‚ùå System configuration test FAILED: ${error.message}`);
    }
  }

  /**
   * Test 8: End-to-end automation flow
   */
  async testEndToEndFlow() {
    console.log('\nüéØ Test 8: End-to-End Automation Flow');
    console.log('-'.repeat(50));
    
    try {
      if (this.testLeadIds.length === 0) {
        throw new Error('No test leads available for end-to-end testing');
      }
      
      const testLeadId = this.testLeadIds[0];
      
      console.log('üîÑ Testing complete automation flow...');
      
      // Step 1: Verify lead exists
      const { data: lead, error: leadError } = await supabase
        .from('leads')
        .select('*')
        .eq('id', testLeadId)
        .single();
      
      if (leadError || !lead) {
        throw new Error('Test lead not found');
      }
      console.log(`‚úÖ Lead verified: ${lead.email}`);
      
      // Step 2: Check workflow jobs
      const { data: jobs, error: jobsError } = await supabase
        .from('workflow_automation')
        .select('*')
        .eq('lead_id', testLeadId)
        .order('scheduled_at', { ascending: true });
      
      if (jobsError || !jobs || jobs.length === 0) {
        throw new Error('No workflow jobs found');
      }
      console.log(`‚úÖ Found ${jobs.length} workflow jobs`);
      
      // Step 3: Process immediate jobs
      console.log('‚ö° Processing immediate workflow jobs...');
      
      // Make some jobs ready for immediate processing
      await supabase
        .from('workflow_automation')
        .update({ scheduled_at: new Date().toISOString() })
        .eq('lead_id', testLeadId)
        .eq('status', 'pending')
        .limit(2);
      
      const processedCount = await this.orchestrator.processPendingJobs(10);
      console.log(`‚úÖ Processed ${processedCount} jobs in end-to-end flow`);
      
      // Step 4: Verify job status updates
      const { data: updatedJobs, error: updatedError } = await supabase
        .from('workflow_automation')
        .select('*')
        .eq('lead_id', testLeadId)
        .order('updated_at', { ascending: false });
      
      if (updatedError) {
        throw new Error('Failed to fetch updated job status');
      }
      
      const statusCounts = {};
      updatedJobs.forEach(job => {
        statusCounts[job.status] = (statusCounts[job.status] || 0) + 1;
      });
      
      console.log('‚úÖ Job status summary:');
      Object.entries(statusCounts).forEach(([status, count]) => {
        console.log(`   ${status}: ${count}`);
      });
      
      this.testResults.endToEnd.passed = true;
      console.log('‚úÖ End-to-end automation flow test PASSED');
      
    } catch (error) {
      this.testResults.endToEnd.errors.push(error.message);
      console.log(`‚ùå End-to-end automation flow test FAILED: ${error.message}`);
    }
  }

  /**
   * Generate comprehensive test report
   */
  generateTestReport() {
    console.log('\nüìä COMPREHENSIVE TEST REPORT');
    console.log('='.repeat(60));
    
    const totalTests = Object.keys(this.testResults).length;
    const passedTests = Object.values(this.testResults).filter(result => result.passed).length;
    const failedTests = totalTests - passedTests;
    
    console.log(`üìã Test Summary:`);
    console.log(`   Total Tests: ${totalTests}`);
    console.log(`   Passed: ${passedTests}`);
    console.log(`   Failed: ${failedTests}`);
    console.log(`   Success Rate: ${((passedTests / totalTests) * 100).toFixed(1)}%`);
    
    console.log('\nüìù Detailed Results:');
    Object.entries(this.testResults).forEach(([testName, result]) => {
      const status = result.passed ? '‚úÖ PASSED' : '‚ùå FAILED';
      console.log(`   ${testName}: ${status}`);
      
      if (result.errors.length > 0) {
        result.errors.forEach(error => {
          console.log(`     Error: ${error}`);
        });
      }
    });
    
    // Overall status
    console.log('\nüéØ OVERALL STATUS:');
    if (passedTests === totalTests) {
      console.log('üéâ ALL TESTS PASSED - Automation system is working correctly!');
    } else if (passedTests >= totalTests * 0.8) {
      console.log('‚ö†Ô∏è  MOSTLY WORKING - Some components need attention');
    } else {
      console.log('‚ùå CRITICAL ISSUES - Automation system needs significant fixes');
    }
    
    // Recommendations
    console.log('\nüí° Recommendations:');
    if (failedTests > 0) {
      console.log('   1. Review failed test errors above');
      console.log('   2. Check database schema and migrations');
      console.log('   3. Verify environment variables are set correctly');
      console.log('   4. Ensure all required services are running');
    } else {
      console.log('   üéâ No issues found - system is ready for production!');
    }
    
    console.log('\nüîß Next Steps:');
    console.log('   1. Run individual component tests if needed:');
    console.log('      - node test-workflow-orchestrator.js');
    console.log('      - node test-miracle-flow.js');
    console.log('   2. Start the automation daemon:');
    console.log('      - node start-automation.js start');
    console.log('   3. Monitor logs for any issues:');
    console.log('      - tail -f logs/combined.log');
  }

  /**
   * Cleanup test data
   */
  async cleanupTestData() {
    console.log('\nüßπ Cleaning up test data...');
    
    try {
      if (this.testLeadIds.length > 0) {
        // Delete workflow automation records
        await supabase
          .from('workflow_automation')
          .delete()
          .in('lead_id', this.testLeadIds);
        
        // Delete test leads
        await supabase
          .from('leads')
          .delete()
          .in('id', this.testLeadIds);
        
        console.log(`‚úÖ Cleaned up ${this.testLeadIds.length} test leads and their workflows`);
      }
    } catch (error) {
      console.log(`‚ö†Ô∏è  Cleanup warning: ${error.message}`);
    }
  }
}

// CLI interface
if (import.meta.url === `file://${process.argv[1]}`) {
  const args = process.argv.slice(2);
  
  if (args.includes('--help') || args.includes('-h')) {
    console.log('üß™ Comprehensive Automation Workflow Tester');
    console.log('\nUsage:');
    console.log('  node test-automation-workflow.js           # Run all tests');
    console.log('  node test-automation-workflow.js --help    # Show this help');
    console.log('\nThis script will test:');
    console.log('  üì° Database connectivity and schema');
    console.log('  üë§ Lead creation and workflow initialization');
    console.log('  üìß Email automation service');
    console.log('  üì± SMS automation service');
    console.log('  üìÖ Meeting booking and monitoring');
    console.log('  üîÑ Workflow orchestrator processing');
    console.log('  ‚öôÔ∏è  System configuration and monitoring');
    console.log('  üéØ End-to-end automation flow');
    process.exit(0);
  }
  
  const tester = new AutomationWorkflowTester();
  
  tester.runAllTests()
    .then(() => {
      console.log('\nüèÅ Automation workflow test completed');
      process.exit(0);
    })
    .catch(error => {
      console.error('\nüí• Test suite crashed:', error.message);
      process.exit(1);
    });
}

export default AutomationWorkflowTester;